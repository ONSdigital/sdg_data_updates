---
title: "16-3-2 QA"
author: "Emma Wood"
date: "14/06/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load-packages, include=FALSE}
library(tidyr)
library(dplyr)
library(ggplot2)
library(kableExtra)
```

```{r include= FALSE}
run_date <- Sys.Date()
csv <- csv %>% 
  mutate(Year_num = as.numeric(as.character(substr(Year, 1, 4))))

```

## 16-3-2 update summary

### Introduction
Rundate: `r Sys.Date()`

Data for `r month.name[month_numeric]` of `r min(csv$Year_num)` to `r month.name[month_numeric]` of `r max(csv$Year_num)` have been created and saved as `r paste0("output_", run_date, ".csv")` in the 16-3-2 Output folder.
  
There are two sets of data for 2009 as there was a change in methodology in 2010.  
- `2009 see note in original data` is the start of the series from 2009 to `r max(csv$Year_num)`.  
- `2009` is the end of the series from `r min(csv$Year_num)`.
  

## Checks
- There are **`r nrow(csv[is.na(csv$Value), ])`** rows with missing values - If greater than 0, check that these are NA in the source data then manually remove these rows from the csv if they are correctly NA.

- If there are multiple numbers for the same selection of disaggregations on the same date, they will show below. Please check which is correct and delete the incorrect one from the csv (for example, in the 2019 amd 2020 datasets, in 2009(a) there are two totals. One is caused by a typo, where the number of people in remand is 13456.02 rather than 13456):
```{r, echo=FALSE}
duplicated_disaggs <- csv %>% 
  group_by(Year, Sex, Age, Nationality) %>% 
  tally() %>%
  filter(n > 1) %>% 
  rename(`number of rows with this disaggregation combination for given year` = n)

if(nrow(duplicated_disaggs) > 0){
  duplicated_disaggs %>% 
    kbl() %>%
    kable_styling()
} else {
  print('There are no duplicated rows')
}

```

## New data compared to live data
Please check the plots and tables below for any differences between the live 
data (which is pulled in from Github) and the new data.  
     
Live data will appear over the top of new data. You should therefore only 
see points for the live data for previous years and only points for the new data 
in the years you are updating. 

If there are zig-zag lines or plots look unusual there may be something 
different in the source data that is causing an issue. This will need to 
be investigated.  
  
The table below each plot shows all instances where the old (live) value does 
not match the new value. It is sorted so the largest absolute differences appear 
first, but can be sorted in other ways using the arrows at the top.

## Differences between live and new data
tiny differences may just be due to differences in rounding, which is not an 
issue.  
Larger differences may be due to revisions, but could also indicate an error in 
the code.    



```{r, echo=FALSE, fig.width=10,fig.height=18}

data_for_plots <- csv %>% 
  mutate(Year = ifelse(Year == "2009 see note in original data", 2009.1, Year_num)) %>% 
  mutate(methodology = ifelse(Year <= 2009, "1","2")) 

# how the plots were done before we decided to just present new methodology data
# (post 2008)

# Please check the plots below for any unusual looking datapoints.  
# As there are two 2009s (due to change in methodology), these are shown here as separate series (methodology 1 and 2).

# data_for_plots %>% 
#   filter(Nationality == "") %>% 
#   ggplot(data = .,
#        aes(x = Year,
#            y = Value)) +
#   geom_line(aes(lty = methodology)) +
#   facet_grid(Age ~ Sex) +
#   ggtitle('By sex and age') +
#   theme(axis.text.x = element_text(angle = 45)) +
#   theme_bw()
# 
# data_for_plots %>% 
#   filter(Age == "" &
#            Sex == "") %>% 
#   ggplot(data = .,
#        aes(x = Year,
#            y = Value)) +
#   geom_line(aes(lty = methodology)) +
#   facet_grid(Nationality ~ .) +
#   ggtitle('By nationality') +
#   theme(axis.text.x = element_text(angle = 45)) +
#   theme_bw()
#   

```



```{r, include = FALSE}

live_data <- read.csv('https://raw.githubusercontent.com/ONSdigital/sdg-data/master/data/indicator_16-3-2.csv') %>% 
  janitor::clean_names() 

new_data <- csv %>% 
  mutate(across(everything(), ~ replace(., is.na(.), ""))) %>%
  mutate(Year = as.integer(Year),
         Value = as.numeric(Value),
         dataset = "new") %>% 
  janitor::clean_names()

# join to the new data
joined_data <- live_data %>% 
  mutate(dataset = "live") %>% 
  bind_rows(new_data) %>% 
  mutate(across(everything(), ~ replace(., is.na(.), ""))) %>% 
  mutate(year = as.integer(year),
         value = as.numeric(value))

# plot data
# sex by age
sex_age_plot <- joined_data %>% 
  filter(nationality == "" | is.na(nationality)) %>% 
  ggplot(.,
         aes(x = year,
             y = value,
             colour = dataset)) +
  geom_point() +
  geom_line(aes(linetype = dataset)) +
  facet_grid(sex ~ age) +
  theme_bw() +
  ggtitle("Sex by age")

nationality_plot <- joined_data %>% 
  filter((sex == "" | is.na(nationality)) &
          (age == "" | is.na(age)) ) %>% 
  ggplot(.,
         aes(x = year,
             y = value,
             colour = dataset)) +
  geom_point() +
  geom_line(aes(linetype = dataset)) +
  facet_wrap(vars(nationality), nrow = 2) +
  theme_bw() +
  ggtitle("Nationality")
         
```


```{r, echo = FALSE, fig.width=10, fig.height = 10}
suppressMessages(print(sex_age_plot))
suppressMessages(print(nationality_plot))

```

```{r, , echo = FALSE}
comparison <- joined_data %>% 
  distinct(year, age, sex, nationality, value, dataset) %>% 
  # first get rid of the duplicate of 2009 (if we only present new method data on the site you can get rid of these 5 lines)
  group_by(year, age, sex, nationality, dataset) %>% 
  mutate(row = n()) %>% 
  mutate(keep = ifelse(year == 2009 & row == 1, FALSE, TRUE)) %>% 
  filter(keep == TRUE) %>% 
  ungroup() %>% 
  # select the columns that are in both the live and new data
  # Columns that have the same entry in every row (e.g. units), or
  # columns like geocode and obs status don't need to go in here.
  select(year, sex, age, nationality, value, dataset) %>% 
  pivot_wider(names_from = dataset,
              values_from = value) %>% 
  mutate(difference = new - live) %>% 
  filter(difference != 0) %>% 
  # put the largest differences at the top
  arrange(desc(abs(difference)))

```
  
  The table below shows all instances where the old value does not match the new 
  value. It is sorted so the largest absolute differences appear first, but can
  be sorted in other ways using the arrows at the top.
```{r, echo = FALSE}
datatable(comparison, 
          rownames = FALSE, 
          filter = "top",
          options = list(dom = 'tp', 
                         pageLength = 5,
                         columnDefs = list(list(
                           className = 'dt-center', targets = 0:3))))
```


## Session Info
```{r}
pander(sessionInfo())
```


