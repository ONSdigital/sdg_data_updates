---
title: "13-1-1"
author: "Steven Jones"
date: "01/11/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE}
load('img.RData')
```



```{r load-packages, include=FALSE}
library(tidyr)
library(dplyr)
library(ggplot2)
library(DT)
```

**Run date and time: `r Sys.time()`**

## Introduction

Motivation for automation: 
Producing the numbers of deaths involves combining a portion of the ONS data to the entirety of the Nomis death by cause of death data. There is a risk of copying the data incorrectly. 

The data from the ONS spreadsheet is unlikely to be updated as it only includes data up to 2018, so there is little concern about a change in its format. Data from 2013 onward is provided by Nomis  and it is not expected that its format should change. Therefore, it is believed that the automation should be stable in this regard. 

Things to check:
At the time of production the Nomis mortality data included rows for the most recent year 2021, but has NA for its value. Update_indicator replaces NA in Value with "".

## Configurations

There are 3 data sources which are fetched by links:

* ONS Number of deaths caused by disasters in England and Wales
* Nomis Number of deaths caused by disasters with number of deaths by all causes. This is broken down by residents of England, Wales, England and Wales, outside England and Wales, and total.
* Nomis Age-Standardised mortality rates for deaths caused by disaster and for all causes of death. This is broken down by residents of England, Wales, England and Wales, outside England and Wales, and total.

The ONS data contains 4 tabs:

* `r ons1` - Number of deaths aggregated for all disasters for all sexes by country by year
* `r ons2` - Number of deaths aggregated for all disasters by sex by country by year
* `r ons3` - Number of deaths aggregated for all sexes by disaster type by country by year
* `r ons4` - Number of death by disaster type by sex by country by year 

In hindsight the analysis could have been completed using `r ons4` only but I felt more confident writing the scripts using all four tables. 

# Basic checks

The number of rows in the output should be checked against the expected number.
The number of rows expected for the number of deaths from 2001 onward, where *y* is the number of years included in the data:  
99*y* + 3(*y* - 12)  

This is because:  
There are 10 * 3 * 3 * *y* rows for the number killed by each disaster type by sex, country and year.  
There are 1 * 3 * 3 * *y* rows for the number killed by any disaster type by sex, country and year.  
There are 1 * 3 * (*y* - 12) rows for Age-Standardised mortality rate by sex and year, but that the earliest available year for this is 2013.  

The code below will check this: 

```{r}
y = max(combined_data$Year) - min(combined_data$Year) + 1
nrow(combined_data) == 99*y + 3*(y - 12)
```

update_indicator has removed all rows which are duplicated on everything but Value (in case we had two rows denoting the same quantity but with different values). As a further check we check the number of unique combinations of Year, Series, Country, Sex and Cause of death found in the output is equal to the number of rows in the output.

```{r}
nrow(combined_data) == nrow(combined_data[c("Country", "Year", "Sex", "Cause of death", "Series")])
```

Now let's fetch the original data and compare it to our updated set. Unless values for previous years have been amended, the two datasets should differ only in the adding of extra rows for the newly included years.  

```{r echo=FALSE}
original_data <- read.csv("https://raw.githubusercontent.com/ONSdigital/sdg-data/master/data/indicator_13-1-1.csv", check.names = FALSE)
original_data <- original_data %>% 
  rename(Units = `Unit measure`) %>% 
  mutate(Country = ifelse(Country=="England and Wales", "", Country)) %>% # Some rows were labelled "England and Wales" not ""
  select(Year, Series, `Cause of death`, Country, Sex, `Observation status`, `Unit multiplier`, `Units`, GeoCode, Value)

# For this first time check where we have removed the 2001-2012 mortality data use the code below ----
original_data <- original_data %>%
  mutate(Year = as.integer(Year)) %>%
  filter(!(Year<=2012 & Series=="Age-standardised mortality rates per 100,000 population")) %>%
  mutate(Year = as.character(Year)) %>% 
  mutate(Value = as.integer(Value))

combined_data <- combined_data %>% 
  mutate(Year = as.integer(Year)) %>%
  filter(Year<=2020) %>% 
  mutate(Year = as.character(Year)) %>% 
  mutate(Value = as.integer(Value))

print(paste("The number of rows in the older data is: ", nrow(original_data)))
print(paste("The number of rows in the updated data is: ", nrow(combined_data)))

diff <- anti_join(combined_data, original_data, by=c("Year", "Series", "Sex", "Country", "Cause of death")) 
print("If there are no inconsistencies then the table below should be empty")
knitr::kable(diff[, c("Year", "Series", "Sex", "Country", "Cause of death", "Value")], "pipe")

# For future updates use the code below ----

print("Below is a table of the non-matching rows for the original and updated data, it should only be populated for years which are later than are covered in the original data")

# diff <- anti_join(combined_data, original_data, by=c("Year", "Series", "Sex", "Country", "Cause of death")) 
# print(nrow(diff))
# knitr::kable(diff[, c("Year", "Series", "Sex", "Country", "Cause of death", "Value")], "pipe")

```